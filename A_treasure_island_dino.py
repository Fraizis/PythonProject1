def max_treasure_value() -> None:
    """
    Решение 1 задания
    A. Сокровища островов пирата Дино

    Легендарный искатель приключений Дино обнаружил древнюю карту сокровищ,
    на которой отмечен архипелаг из n островов. На каждом острове спрятан
    клад определённой ценности, но острова соединены между собой опасными
    подводными туннелями, кишащими морскими чудовищами.

    Дино начинает своё путешествие с острова номер 1 и хочет
    собрать как можно больше сокровищ. Однако из-за проклятья древних
    пиратов каждый остров можно посетить только один раз. После посещения острова
    туннель, ведущий к нему, магически запечатывается навсегда.

    Дино может завершить своё путешествие на любом острове — ему не
    обязательно возвращаться на начальный остров.

    Помогите Дино найти максимальную суммарную ценность сокровищ,
    которую он сможет собрать!

    Формат ввода

    Первая строка содержит два целых числа n и m (1 ≤ n ≤ 20, 0 ≤ m ≤ n(n-1)/2) —
    количество островов и количество туннелей соответственно.

    Вторая строка содержит n целых чисел v₁, v₂, ..., vₙ (1 ≤ vᵢ ≤ 10⁶) —
    ценность сокровищ на каждом острове.

    Следующие m строк содержат по два целых числа a и b (1 ≤ a, b ≤ n, a ≠ b),
    означающих, что между островами a и b существует туннель (туннели двунаправленные).

    Формат вывода

    Выведите одно целое число — максимальную суммарную ценность сокровищ,
    которую может собрать Дино.

    Пример 1

    Ввод

    4 4
    10 30 20 5
    1 2
    2 3
    3 4
    1 4

    Вывод

    65

    Пример 2

    Ввод

    5 3
    100 50 75 25 60
    1 2
    2 3
    4 5

    Вывод

    225

    Пример 3

    Ввод

    3 0
    40 30 20

    Вывод
    40

    Пример 4

    Ввод

    6 7
    15 25 35 45 55 65
    1 2
    2 3
    3 4
    4 5
    5 6
    1 6
    2 5

    Вывод

    240

    Примечания

    В первом примере граф островов образует цикл: 1-2-3-4-1.
    Дино может пройти маршрут 1 → 2 → 3 → 4, собрав сокровища ценностью
    10 + 30 + 20 + 5 = 65. Это максимально возможная сумма, так как он посетил все острова.

    Во втором примере граф состоит из двух отдельных компонент:
    острова {1,2,3} и острова {4,5}. Дино начинает с острова 1 и может дойти
    только до островов 2 и 3. Оптимальный путь: 1 → 2 → 3,
    собрав 100 + 50 + 75 = 225. Острова 4 и 5 недоступны из-за отсутствия соединения.

    В третьем примере туннелей нет, поэтому Дино может посетить
    только остров 1, получив 40 золотых монет.

    В четвёртом примере Дино может посетить все острова
    различными способами. Один из оптимальных маршрутов: 1 → 6 → 5 → 2 → 3 → 4,
    собрав 15 + 65 + 55 + 25 + 35 + 45 = 240.
    """

    # islands_tunnels_count = input().split(' ')

    # island_tunnels = list(map(int, islands_tunnels_count))

    # islands = island_tunnels[0]
    islands = 4

    # tunnels_count = island_tunnels[1]
    tunnels_count = 4

    # treasure_values = input().split(' ')
    treasure_values = ['10', '30', '20', '5']

    if len(treasure_values) != islands or islands == 0:
        print(0)
        return

    treasures = list(map(int, treasure_values))

    tunnels = list()

    # for tun in range(tunnels_count):
    #     tunnel = input().split(' ')
    #     tunnels.append(list(map(int, tunnel)))
    tunnels = [[1, 2], [2, 3], [3, 4], [1, 4]]

    visited_isles = []
    total_value = treasures[0]

    if tunnels_count != 0:

        for num_1 in range(len(tunnels)):
            print(tunnels[num_1])
            for num_2 in range(num_1 + 1, len(tunnels)):
                print(' ', tunnels[num_2])

                if tunnels[num_1][0] and tunnels[num_1][1] not in visited_isles:

                    first_isl = tunnels[num_1][0]
                    second_isl = tunnels[num_1][1]

                    total_value += treasures[num_2]

                    visited_isles.append(first_isl)

                # if second_isl not in tunnels[num_2]:
                #     break

            if tunnels[num_1][1] not in tunnels[num_2]:
                break

    print(total_value or 0)


if __name__ == '__main__':
    max_treasure_value()
